#pragma config(Sensor, in1,    driveGyro,      sensorGyro)
#pragma config(Sensor, dgtl1,  liftBump,       sensorTouch)
#pragma config(Motor,  port1,           mobileLeft,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           coneLeft,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftDrive1,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           leftDrive2,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightLift,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rightDrive1,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightDrive2,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           coneRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          mobileRight,   tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"


/////////////////////////////////////////////////////////////////////////////////////////
//
//Basic Movement Start
//
/////////////////////////////////////////////////////////////////////////////////////////
//DRIVE FUNCTIONS
void manualDrive() {
	motor[rightDrive1] = vexRT[Ch3] - vexRT[Ch1];
	motor[rightDrive2] = vexRT[Ch3] - vexRT[Ch1];
	motor[leftDrive1] = vexRT[Ch3] + vexRT[Ch1];
	motor[leftDrive2] = vexRT[Ch3] + vexRT[Ch1];
}

//LIFT FUNCTIONS
void liftUp(int speed) {
	motor[leftLift] = speed;
	motor[rightLift] = speed;
}

void liftDown(int speed) {
	motor[leftLift] = 0 - speed;
	motor[rightLift] = 0 - speed;
}

void liftStop() {
	motor[leftLift] = 0;
	motor[rightLift] = 0;
}

void manualLift() {
	if (vexRT[Btn6U] == 1) {
		liftUp(100);
	}
	else if (vexRT[Btn6D] == 1) {
		liftDown(100);
	}
	else {
		liftStop();
	}
}

//INTAKE FUNCTIONS
void intakeUp(int speed) {
	motor[coneRight] = speed;
	motor[coneLeft] = speed;
}

void intakeDown(int speed) {
	motor[coneRight] = 0 - speed;
	motor[coneLeft] = 0 - speed;
}

void intakeStop() {
	motor[coneRight] = 0;
	motor[coneLeft] = 0;
}

void manualIntake() {
	if (vexRT[Btn5U] == 1) {
		intakeUp(100);
	}
	else if (vexRT[Btn5D] == 1) {
		intakeDown(100);
	}
	else {
		intakeStop();
	}
}

//MOBILE GOAL INTAKE FUNCTIONS
void mobileOut(int speed) {
	motor[mobileRight] = speed;
	motor[mobileLeft] = speed;
}

void mobileIn(int speed) {
	motor[mobileRight] = 0 - speed;
	motor[mobileLeft] = 0 - speed;
}

void mobileStop() {
	motor[mobileRight] = 0;
	motor[mobileLeft] = 0;
}

void manualMobile() {
	if (vexRT[Btn7U] == 1) {
		mobileOut(100);
	}
	else if (vexRT[Btn7D] == 1) {
		mobileIn(100);
	}
	else {
		mobileStop();
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//Basic Movement End
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//
//void pre_auton(), task autonomous(), and task usercontrol() Start
//
/////////////////////////////////////////////////////////////////////////////////////////
void pre_auton() {}

task autonomous() {}

task usercontrol() {
	while(true) {
		manualLift();
		manualIntake();
		manualMobile();
		manualDrive();
	}
}
/////////////////////////////////////////////////////////////////////////////////////////
//void pre_auton(), task autonomous(), and task usercontrol() End
/////////////////////////////////////////////////////////////////////////////////////////
